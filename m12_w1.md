## 一、介绍
issue：**Log reason for exceptions**。
现在的 Sail RISC-V C 模型，在 trap 时 C 这边只知道：
- `is_interrupt`
- `cause`：架构定义的异常编码
但在调试内存/页表相关问题时，经常需要更细一点的信息，比如：
- 这次 trap 是因为访问落在物理内存外了吗？
- 还是页表某个 PTE 的保留位不合法？
- 或者未来可能还有其他“内部原因”。
## 二、修改说明
### 1. 在 Sail 里定义「trap 的额外原因」类型
在 `model/core/types_ext.sail` 里新加了一个联合类型：
```
// Additional information about the underlying cause of a trap.
// This is purely for debugging / logging and does not affect the ISA state.
union trap_reason = {
  Trap_reason_none : unit,
  Access_not_in_physical_memory : unit,
  Invalid_pte_reserved_bits_nonzero : (physaddrbits, xlenbits)
}
```
- 注释：**不影响 ISA 状态**，只是 for debugging/logging；
- 目前只定义了三个 variant：
    - `Trap_reason_none`：默认值，表示没有额外信息；
    - `Access_not_in_physical_memory`：访问跑出物理内存（用作 demo）；
    - `Invalid_pte_reserved_bits_nonzero`：为将来 PTE 保留位错误预留，带 `(pte 地址, pte 内容)`。
### 2. 给 `sync_exception` 结构体加 `reason` 字段
在 `model/exceptions/sync_exception.sail`：
```
struct sync_exception = {
  trap    : ExceptionType,
  excinfo : option(xlenbits),
  ext     : option(ext_exception),   // for extensions
  reason  : trap_reason
}
```
现在每个同步异常除了原来的 `trap` / `excinfo` / `ext`，还带一个 `reason`。
### 3. 新增 `handle_exception_with_reason(...)` helper
在 `model/sys/sys_control.sail`：
```
function handle_exception_with_reason(xtval : xlenbits,
                                      e     : ExceptionType,
                                      r     : trap_reason) -> unit = {
  let t : sync_exception = struct {
    trap    = e,
    excinfo = xtval_exception_value(e, xtval),
    ext     = None(),
    reason  = r
  };
  set_next_pc(exception_handler(cur_privilege, CTL_TRAP(t), PC))
}

function handle_exception(xtval : xlenbits, e : ExceptionType) -> unit = {
  handle_exception_with_reason(xtval, e, Trap_reason_none())
}
```
知道具体原因，就调用 `handle_exception_with_reason(…, reason)`；
老代码继续调用 `handle_exception`，会自动套一层 `Trap_reason_none()`，**完全兼容原行为**。
### 4. 在 trap 处理路径里“多带一个参数”
在 `model/sys/sys_control.sail` 里，让 `trap_reason` 一路往下传：
```
function trap_handler(del_priv : Privilege,
                      c        : TrapCause,
                      pc       : xlenbits,
                      info     : option(xlenbits),
                      ext      : option(ext_exception),
                      reason   : trap_reason)
                     -> xlenbits = {
  let is_interrupt = trapCause_is_interrupt(c);
  let cause        = trapCause_bits(c);

  trap_callback(is_interrupt, cause, reason);
  ...
}
```
- `trap_handler` 新增了一个 `reason : trap_reason` 参数；
- `exception_handler` 在处理 `CTL_TRAP(e)` 时：
```
trap_handler(del_priv, Exception(e.trap), pc, e.excinfo, e.ext, e.reason)
```
- `handle_interrupt` 是中断，不带额外信息，所以传 `Trap_reason_none()`：
```
handle_interrupt(i, del_priv) =
  set_next_pc(trap_handler(del_priv, Interrupt(i), PC, None(), None(), Trap_reason_none()))
```
### 5. Sail 层的 `trap_callback` 也加上 reason
在 `model/core/callbacks.sail`：
```
val trap_callback =
  pure {c: "trap_callback"} :
    (/* is_interrupt */ bool,
     /* interrupt/exception cause */ exc_code,
     /* extra debug info */ trap_reason) -> unit

```
Sail FFI 跟 C 的桥。
### 6. C ：让 C 模型认识 `trap_reason`
在 `c_emulator/riscv_callbacks.h` / `riscv_callbacks_if.h` 中：
```
#include "sail_riscv_model.h"
typedef struct ztrap_reason trap_reason;
...
unit trap_callback(bool is_interrupt, fbits cause, trap_reason reason);
```
Sail 生成的 C 代码里会有一个：
`struct ztrap_reason { ... };`
通过 typedef 把它重命名`trap_reason`，然后：
- C FFI 函数 `trap_callback` 变成三个参数；
- C++ 的 `callbacks_if` 虚函数也是三个参数：
```
virtual void trap_callback(bool is_interrupt,
                           fbits cause,
                           trap_reason reason)
```
- `riscv_callbacks.cpp` 里广播给所有 callbacks：
```
unit trap_callback(bool is_interrupt, fbits cause, trap_reason reason)
{
  for (auto c : callbacks) {
    c->trap_callback(is_interrupt, cause, reason);
  }
  return UNIT;
}
```
- `rvfi_callbacks` 里暂时只是 `(void)reason;`，保持行为不变。
### 7. log_callbacks
```
#include <cstdio>

void log_callbacks::trap_callback(bool is_interrupt,
                                  fbits cause,
                                  trap_reason reason)
{
    std::fprintf(stderr, "trap: is_interrupt=%d cause=%llu\n",
                 is_interrupt ? 1 : 0,
                 (unsigned long long)cause);

    switch (reason.kind) {
    case Kind_zTrap_reason_none:
        std::fprintf(stderr, "  reason: none\n");
        break;
    case Kind_zAccess_not_in_physical_memory:
        std::fprintf(stderr, "  reason: access_not_in_physical_memory\n");
        break;
    case Kind_zInvalid_pte_reserved_bits_nonzzero:
        std::fprintf(stderr, "  reason: invalid_pte_reserved_bits_nonzero\n");
        break;
    default:
        std::fprintf(stderr, "  reason: <unknown kind=%d>\n",
                     (int)reason.kind);
        break;
    }
}
```
### 8. 示例
在 `model/postlude/step.sail`：
```
Step_Fetch_Failure(vaddr, e) =>
  handle_exception_with_reason(bits_of(vaddr), e, Access_not_in_physical_memory()),
...
Step_Execute(Memory_Exception(vaddr, e), _) =>
  handle_exception_with_reason(bits_of(vaddr), e, Access_not_in_physical_memory()),
```
- 取指访问错误（`E_Fetch_Access_Fault`）和数据访问类的 `Memory_Exception`
现在都会带上 `Access_not_in_physical_memory()` 这个 reason。
输出：
`trap: is_interrupt=0 cause=1   reason: access_not_in_physical_memory`
