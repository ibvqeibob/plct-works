# Sail RISC-V C 模型 per-step 回调接口实现说明

## 1. 背景

在现有 Sail RISC-V C 模型中，已经提供了多种事件回调，例如：

- 内存访问回调（读 / 写）；
- 通用寄存器写回调；
- PC 变化、trap 等回调。

这些回调可以在**特定事件发生时**被触发，用来打印日志或做验证工作。但在执行循环层面，**缺少一个“每步执行前后”的统一观察点**：

- 想统计“执行了多少步”，只能在多处事件里分散统计；
- 对于“没有触发特定事件”的指令（例如只更新内部状态机），无法统一感知；
- 接入 RVFI / trace 等工具时，希望在“每次 step 调用前后”能收集完整的状态。

为了解决这些问题，本次实现了 **per-step 回调接口**，在不破坏原有回调体系的前提下，增加一个统一的、可扩展的 hook。

---

## 2. 接口设计

### 2.1 `callbacks_if` 中新增虚函数

在 `callbacks_if` 中增加两个虚函数，用于描述“每步执行前 / 后”的回调。  
采用默认空实现，保证对现有使用者完全兼容：

    virtual void pre_step(bool is_waiting) {}
    virtual void post_step(bool is_waiting) {}

说明：

- `pre_step`：在执行一步指令之前被调用；
- `post_step`：在执行一步指令之后被调用；
- `is_waiting` 参数用于标记当前这一步是否处于等待状态（例如 WFI / idle），方便外部区分“真正执行的步数”和“空转步骤”。

用户只需要在自己的派生类中重写其中一个或两个函数，即可在每步执行时插入自定义逻辑，例如统计、打印日志或输出 RVFI 包。

### 2.2 `riscv_callbacks.cpp` 中新增广播函数

在回调实现文件中，为 per-step 回调增加两个统一的入口函数：

    void callbacks_pre_step(bool is_waiting);
    void callbacks_post_step(bool is_waiting);

内部通过遍历全局维护的回调列表：

    std::vector<callbacks_if*> callbacks;

依次调用各个回调对象的 `pre_step` / `post_step`：

    void callbacks_pre_step(bool is_waiting) {
        for (auto *c : callbacks) {
            c->pre_step(is_waiting);
        }
    }

    void callbacks_post_step(bool is_waiting) {
        for (auto *c : callbacks) {
            c->post_step(is_waiting);
        }
    }

这样，执行层只需要调用 `callbacks_pre_step` / `callbacks_post_step`，不用关心外部挂了多少个回调对象、各自做什么事情，保持了良好的模块划分。

---

## 3. 执行流程接入

在 `run_sail()` 的主循环中接入 per-step 回调，使其在每次 `ztry_step` 调用前后都能触发：

    while (!finished) {
        // 根据当前模型状态判断是否处于等待，例如 WFI
        bool is_waiting = ...;

        // 执行前回调：可用于检查断点、准备统计等
        callbacks_pre_step(is_waiting);

        // 执行一步 Sail 生成的 C 模型代码
        ztry_step(...);

        // 执行后回调：可用于记录 PC / 寄存器变更、输出 trace 等
        callbacks_post_step(is_waiting);
    }

其中 `is_waiting` 的典型用法：

- `is_waiting == false`：说明这一步是正常指令执行；
- `is_waiting == true`：说明这一步只是等待（空转），外部在统计或生成 trace 时可以选择忽略。

通过这种方式，我们在不修改 Sail 生成代码的前提下，为整个执行过程增加了一个统一的 per-step hook。

---

## 4. 初步验证与效果

为了验证接口的可用性和正确性，实现了一个简单的 `log_callbacks` 示例类，在 `post_step()` 中做基本统计和打印：

- 维护两个计数器：
  - 总执行步数 `step`；
  - 非等待步数 `non_waiting_step`；
- 每次 `post_step` 被调用时：
  - `step` 自增 1；
  - 如果 `!is_waiting`，则 `non_waiting_step` 也自增 1；
  - 可以选择性地打印当前 PC、指令等信息，确认回调触发的时机。

使用 `hello.elf` 等简单程序进行测试，结果表明：

- C 模型可以正常运行，新增 per-step 回调不会影响原有功能；
- `step` 与 `non_waiting_step` 的统计结果符合预期；
- 在执行过程中，`post_step` 能稳定在每一步后被调用，可以看到连续的 PC 变化日志。

通过这次改动，Sail RISC-V C 模型的回调系统从“仅支持事件型回调”，扩展为“事件型回调 + per-step 统一入口”，为后续接入指令级 trace、RVFI、性能统计以及调试器等工具提供了一个清晰、统一且向后兼容的基础。
