# RISC-V PLIC 学习笔记

## 1. PLIC 理解

- **PLIC = 平台级中断控制器**（Platform-Level Interrupt Controller）
- 作用：把多个外设产生的 **外部中断** 汇聚、仲裁后，通知到各个 **hart context** 的外部中断入口。
- 交互方式：通过一组 **MMIO 寄存器**（priority / pending / enable / threshold / claim&complete）。
注：
  - PLIC **不是 ISA 指令扩展**，而是平台设备规范。
  - PLIC 主要处理 **external interrupt（外部中断）** 这一路；rsicv中其他两种陷阱software/timer不走 PLIC。

---

## 2. 概念理解

### 2.1 hart / SMT
- **hart**：hardware thread，独立硬件执行上下文（对软件看起来像一个单核CPU）。
- **SMT（超线程）**：一个物理核可能包含多个 hart（多个硬件线程上下文），共享执行资源。
### 2.2 Interrupt Source（中断源）
- 外设/系统中产生中断请求的来源。
- 每个 source 有一个全局 **Interrupt ID**。
### 2.3 Interrupt ID（中断标识符）
- ID 从 **1** 开始分配。
- **ID=0** 保留，表示“无中断（no interrupt）”。
- 当两个中断优先级相同，**ID 小的优先**（tie-break）。
### 2.4 Interrupt Target / Hart Context（中断目标 / hart 上下文）
- **Target 通常是 hart context**：某个 hart 上的某个特权态（例如 M-mode、S-mode）。
- 不是所有上下文都必须是 target：是否把外部中断委派到低特权态，取决于平台/内核策略。
- PLIC 的通知在 CPU 侧体现为：
  - M-mode：`mip.meip`
  - S-mode：`sip.seip`
### 2.5 Interrupt Gateway（中断网关）
- 把外设侧不同风格的中断信号统一成 PLIC 能处理的请求形式：
  - **level-triggered（电平触发）**
  - **edge-triggered（边沿触发）**
  - **MSI（消息触发中断）**
注：
  - 同一 source 在任意时刻 **最多只允许一个 pending 请求**（直到完成/complete 才允许下一次）。
  - 对 level-trigger：complete 后如果电平仍为有效，会再次产生请求。
  - 网关一旦把请求送到 PLIC core，通常 **不能撤回**；即使外设后来把电平放下了，PLIC core 的 pending 仍可能被 handler claim 到。
### 2.6 Interrupt Notification（中断通知）
- 每个 target/context 在 PLIC core 内有一个 **EIP（External Interrupt Pending）**状态，表示“对该 target 有可服务的外部中断”。
- 通知可能通过简单导线或系统互连消息到达目标。
注：
  - 通知可能**延迟**甚至**过期**：当收到通知时，中断可能已经被另一个目标 claim 走。
  - 因此：目标进入外部中断处理后，**claim 返回 0 是合法的**。

---

## 3. PLIC 仲裁规则

### 3.1 候选集合（Candidate）
一个中断源 `id` 只有在满足这些条件时，才算“对该 context 可见”：
- `pending[id] == 1`
- `enable[context][id] == 1`
- `priority[id] > threshold[context]`
- `priority[id] != 0`（priority=0 等价禁用）
### 3.2 仲裁规则（Arbitration）
- 选择候选集合中 **priority 最大**的中断源
- priority 相同，选择 **ID 最小**的中断源
### 3.3 通知条件（EIP / meip / seip）
- 若候选集合非空（存在胜者），则该 context 的外部中断 pending（EIP）为 1
- CPU 侧表现为 `meip` 或 `seip` pending

---

## 4. PLIC 寄存器交互

> PLIC 是 MMIO 寄存器接口：软件通过读写寄存器来配置与完成中断握手。

### 4.1 priority（优先级）
- 每个 Interrupt ID 都有一个可编程优先级值。
注：
  - `priority = 0` 表示该中断源永远不会触发（等价禁用）
  - `priority = 1` 是最低有效优先级
### 4.2 pending（挂起位）
- PLIC core 保存每个中断源的 pending 状态。
- pending 通常按位图组织（每 32 个 source 一个 word）。
### 4.3 enable（使能位）
- **按 context 分组**：每个 context 有自己的一套 enable 位图。
- 表示该 context 是否允许某个 ID 的中断打断自己。
### 4.4 threshold（阈值）
- **按 context 分组**：每个 context 一个 threshold。
- 过滤规则是 **严格大于**：
  - 只有 `priority > threshold` 的中断才会对该 context 生效
- threshold=0：允许所有 priority>0 的中断
### 4.5 claim / complete（认领 / 完成）
PLIC 握手环节：
- **claim（读 claim/complete 寄存器）**
  - 返回该 context 当前可见的“最高优先级 pending 中断”的 ID
  - 如果没有，返回 0
  - 读操作通常有副作用：会把该 ID 从 pending 集合中移走（使其不再被重复 claim）
- **complete（写 claim/complete 寄存器）**
  - 写回刚才 claim 到的 ID，表示中断处理完成
  - 该动作允许同一 source 的后续中断再次被网关/PLIC 挂起

---

## 5. 中断处理流程

1. **Interrupt Source** 产生中断信号  
2. **Gateway** 将信号转换成统一的中断请求，发送给 **PLIC core**  
3. **PLIC core** 把请求记录为 pending（IP 位）  
4. 若对某个 target/context：
   - enable=1 且 priority>threshold
   - 则 PLIC 向 target 发出中断通知（EIP=1 → `meip/seip` pending）
5. target 进入外部中断处理后，执行 **claim**
   - 得到某个中断 ID（或 0）
   - PLIC 清除对应 pending
6. handler 根据 ID 服务设备，并清除设备的中断原因
7. handler 写 **complete = ID**
8. Gateway 收到完成语义后，允许该 source 的下一次中断请求再次送出
