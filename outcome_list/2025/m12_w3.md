# Plumb `TrapReason` from Sail traps into C `trap_callback`

## 背景

* Issue: [https://github.com/riscv/sail-riscv/issues/1326](https://github.com/riscv/sail-riscv/issues/1326)
* PR: **Plumb trap_reason from Sail traps into C callbacks** #1415

`trap_callback(is_interrupt, cause)` 只能 trap（mcause/scause，但缺少更底层的失败原因

### PR 目标

* 在 Sail 内部捕获更细粒度的失败原因（`TrapReason`）
* 在最终 trap 发生时（`trap_handler` 调用 `trap_callback`），把 `reason` 一起传到 C/C++ callback

---

## 思路

### 1) 不改 `sync_exception / CTL_TRAP` 类型

Sail 里 trap 的主数据结构是：

* `CTL_TRAP : sync_exception`
* `trap_handler(del_priv, TrapCause, pc, info, ext)` 负责落地 trap

之前我把 `sync_exception` 扩成 `sync_exception_with_reason`，会导致大量文件需要跟着改（各种构造 `CTL_TRAP(...)` 的位置都会崩），所以改为：

* 新增一个全局寄存器 `pending_trap_reason : TrapReason`
* 在“准备触发异常”时先写入 `pending_trap_reason`
* 真正进入 `exception_handler -> trap_handler` 时读出该值、传给 `trap_callback`，随后清回默认

---

## 实现

## 1) 扩展 C callback：`trap_callback` 增加第三个参数

### Sail（`model/core/callbacks.sail`）

原本：

```
val trap_callback : (bool, exc_code) -> unit
```

改为：

```
val trap_callback : (bool, exc_code, TrapReason) -> unit
```

### C++ 侧

* `PlatformInterface::trap_callback(bool, fbits, const hart::zTrapReason&)`
* `ModelImpl::trap_callback(bool, fbits, const hart::zTrapReason&)`
* `callbacks_if::trap_callback(hart::Model&, bool, fbits, const hart::zTrapReason&)`

---

## 2) Sail trap：把 reason 从异常路径传到 `trap_callback`

文件：`model/sys/sys_control.sail`

### (1) 新增寄存器

```
register pending_trap_reason : TrapReason = Trap_Reason_Unclassified()
```

### (2) 修改 `trap_handler`

* 增加 `reason` 参数
* 传给 callback：

```
trap_callback(is_interrupt, cause, reason);
```

### (3) 引入 `handle_exception_with_reason`

```
function handle_exception(xtval, e) =
  handle_exception_with_reason(xtval, e, Trap_Reason_Unclassified())
```

中断路径先全部传 `Trap_Reason_Unclassified()`。

---

## 3) 从 PTW 错误推导 `TrapReason`

文件：`model/sys/vmem_ptw.sail`

### (1) 新增转换函数

```
function ptw_error_to_trap_reason(e : PTW_Error) -> TrapReason = ...
```

### (2) 升级 `translateAddr` 的返回类型

将 `translateAddr` 的返回类型从 `ExceptionType` 升级为：

* `TR_Result(physaddr, (ExceptionType, TrapReason))`

即：失败时返回 `(exc, reason)`。

当 translation / PTW 失败时：

* `exc = translationException(ac, f)`
* `reason = ptw_error_to_trap_reason(f)`

---

## 4) 调整 `Memory_Exception` 和若干调用点

为了让 `reason` 进入最终 trap，需要让内存异常链路能携带 reason。

因此将：

* `ExecutionResult.Memory_Exception` 从 `(virtaddr, ExceptionType)`
* 改为 `(virtaddr, (ExceptionType, TrapReason))`

同时修改 `step.sail`：

* `Step_Fetch_Failure` 升级为携带 `(ExceptionType, TrapReason)`

  * 目前 fetch 的翻译失败 reason 暂时用 `Unclassified`（因为 `F_Error` 仍然只携带 `ExceptionType`）
* 在 dispatch 时，遇到 `Memory_Exception` 或 `Step_Fetch_Failure`，统一改为调用：

  * `handle_exception_with_reason(xtval, e, r)`

---

## 5) 编译出错与修复规则

改动涉及很多 `match ... { Err(e,_) => ... }` 位置，其中有些返回的 `Err payload` 已经从 `ExceptionType` 变成了 `(ExceptionType, TrapReason)`。

按以下规则逐个修：

* 如果 `Err payload` 已是 pair，则用：

  * `Err((e, r), _) => ...` 透传
  * 或只取 `e`（例如某函数只要 `ExceptionType`）
* 如果 `Err payload` 仍是单个 `ExceptionType`，则保持：

  * `Err(e)` 或 `Err(e, _)`
  * 并在需要生成 `(ExceptionType, TrapReason)` 时用 `Trap_Reason_Unclassified()`

已修改文件包括：

* `zaamo_insts.sail`
* `zicbom_insts.sail`
* `zicboz_insts.sail`
* `vmem_utils.sail`
* `fetch.sail` / `fetch_rvfi.sail`
* `base_insts.sail`
