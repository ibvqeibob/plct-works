Sail RISC-V PLIC实现（min版）
1. PLIC 介绍
PLIC 用来把 SoC 上的外设中断源（interrupt sources）汇聚，并分别投递给不同 hart 的不同特权级上下文context。context 可以理解为hart的两个特权模式上下文。
hart0 的 M-mode 是一个 context
hart0 的 S-mode 是一个 context
1.1 三组状态寄存器
- pending[source]：某个 source 是否“有中断等待处理”
- enable[context][source]：某个 context 是否允许接收该 source
- priority[source] + threshold[context]：
  - priority[source]：该 source 的优先级
  - threshold[context]：该 context 的阈值，只接收 priority > threshold 的中断
1.2 claim/complete 寄存器（与cpu交互）
PLIC 的 claim/complete 是同一个 MMIO 地址：
- 读该地址（claim）：PLIC 会原子地选择该 context 当前最高优先级 pending 中断的 ID 并返回；同时把对应 pending bit 清掉。如果没有可用中断，返回 0。
- 写该地址（complete）：写回刚刚处理完的中断 ID。
2. PLIC 寄存器地址规范
2.1 规范布局
所有寄存器都按 32-bit 访问（LW/SW 原子访问）
(1) Priority 寄存器
- base + 0x000000：source0 保留（不存在）
- base + 0x000004 + 4*id：source id 的 priority（一直到 id=1023 → base+0x000FFC）
- 总计 1024 个 source → 1024 * 4 = 0x1000 字节
(2) Pending 寄存器
- base + 0x001000：pending bits 0..31（32-bit word）
- ...
- base + 0x00107C：pending bits 992..1023
- 1024 bits = 128 bytes = 0x80
(3) Enable 寄存器（每个 context 一份 enable 位图，stride=0x80）
- base + 0x002000 + ctx*0x80：context ctx 的 enable block 起始
- 0x80 ：1024 sources → 1024 bits → 128 bytes → 0x80
(4) Context 控制区（每个 context 一页 4KB，stride=0x1000）
- base + 0x200000 + ctx*0x1000 + 0x0：Threshold 寄存器
- base + 0x200000 + ctx*0x1000 + 0x4：Claim/Complete 寄存器
3. min实现
3.1 假设（简化点）
- sources：plic_nsrc = 64（ID 0..63，0 保留）
- contexts：plic_nctx = 2（ctx0 = hart0/M，ctx1 = hart0/S）
- pending 的产生：不是由外设网关，而是允许对 pending 寄存器写入来置位 pending
3.2 状态变量
- plic_priority : list(bits(32))：每个 source 的优先级
- plic_pending : bits(64)：pending 位图
- plic_enable_m / plic_enable_s : bits(64)：两个 context 的 enable 位图
- plic_threshold_m / plic_threshold_s : bits(32)：两个 context 的 threshold
- plic_claimed : bits(64)：in-service/claimed 标记
3.3 plic_claimed介绍
规范说 claim 会清 pending bit，并让该中断进入“处理中”状态
- claim 时：clear pending[id] + set claimed[id]
- complete 时：clear claimed[id]
4. 一次外部中断成功处理的流程
4.1 阶段 0：软件初始化
目前是测试程序、后续一般会在OS时也会写。
- 写 priority：plic_store 里 if off < PLIC_OFF_PRIORITY_END 分支
  - plic_list32_set(plic_priority, id, wdata)
- 写 enable：
  - ctx0(M)：off == PLIC_OFF_ENABLE_BASE / +4
  - ctx1(S)：off == PLIC_OFF_ENABLE_BASE + PLIC_ENABLE_STRIDE / +4
- 写 threshold：
  - ctx0(M)：off == PLIC_OFF_CTX_BASE
  - ctx1(S)：off == PLIC_OFF_CTX_BASE + PLIC_CTX_STRIDE
- 写完都会plic_update_mip()
4.2 阶段 1：外设触发 → pending 置位
真实硬件：外设信号进入 PLIC gateway，硬件置 pending[id]=1。  
目前通过非标准注入来置位 pending：
- plic_store 里：
  - off == PLIC_OFF_PENDING_BASE：写低 32 位 pending
  - off == PLIC_OFF_PENDING_BASE + 4：写高 32 位 pending
4.3 阶段 2：PLIC 仲裁
- plic_best_id_from(ctx, i, best_id, best_pr)
  - 从 i=1..63 扫描候选
  - 条件：
    - enable[ctx][i] == 1
    - pending[i] == 1
    - claimed[i] == 0
    - priority[i] > threshold[ctx]，priority 相同按 ID 最小
  - 选择规则：priority 最大；
- plic_best_id(ctx) = plic_best_id_from(ctx, 1, 0, 0)
4.4 阶段 3：拉起 CPU 的外部中断 pending 位（MEIP/SEIP）
对应函数：plic_update_mip()
bid_m = plic_best_id(0)；bid_s = plic_best_id(1)
mip[MEI] = (bid_m != 0)；mip[SEI] = (bid_s != 0)
4.5 阶段 4：CPU 进入 trap handler，并claim
CPU 进入中断处理后，会读 claim/complete 寄存器来拿到 source ID。
ctx0(M) claim：off == PLIC_OFF_CTX_BASE + 4
ctx1(S) claim：off == PLIC_OFF_CTX_BASE + PLIC_CTX_STRIDE + 4
以 ctx0 为例：
1. id = plic_best_id(0)（再次仲裁）
2. 若 id != 0：
  - plic_pending = clear(plic_pending, id)（claim 清 pending）
  - plic_claimed = set(plic_claimed, id)（进入 in-service）
  - 清理 id0（保留）
  - plic_update_mip()
  - 返回 id（32-bit）
3. 否则返回 0
4.6 阶段 5：CPU 执行设备 ISR
- 根据 id 分发到 UART、VIRTIO、GPIO 等设备的 handler
- 处理完成后准备 complete
4.7 阶段 6：CPU 写 complete
对应plic_store函数中的：
ctx0(M) complete：off == PLIC_OFF_CTX_BASE + 4
ctx1(S) complete：off == PLIC_OFF_CTX_BASE + PLIC_CTX_STRIDE + 4
1. id = unsigned(wdata)
2. 若合法
  - 调用 plic_update_mip() 重新计算 MEIP/SEIP：
  - plic_claimed = clear(plic_claimed, id)（结束 in-service）
  - 清 id0
5. Min vs Fin目前限制
1. sources 只有 64：xv6/Linux 可能需要更多；并且规范默认最大 1024。
2. contexts 只有 2（只覆盖 hart0 M/S）：xv6/Linux等OS都会在多 hart 上需要每 hart 的 S-context（甚至 M-context）。
3. pending 注入是非标准：真实 PLIC pending 通常不是软件写入（而是网关硬件置位）
4. priority 用 list ：后续扩展到 1024 entries ，应该用vector数据结构
5. mip 更新是“当前 hart 的 mip”：如果以后要多 hart，需要对每个 hart/context 更新各自的外部中断 pending 位  
6.流程 ↔ 代码
流程阶段
规范动作
代码
初始化 priority
软件写 priority[id]
plic_store: off < PLIC_OFF_PRIORITY_END
初始化 enable
软件写 enable[ctx][word]
plic_store: enable_m/enable_s 四个分支
初始化 threshold
软件写 threshold[ctx]
plic_store: threshold_m / threshold_s
外设触发中断
硬件置 pending[id]=1
MVP：plic_store 写 pending 注入分支
PLIC 仲裁
选 best_id(ctx)
plic_best_id_from / plic_best_id
拉起外部中断线
设置 MEIP/SEIP
plic_update_mip()
CPU claim
读 claim/complete → 返回 ID 并清 pending
plic_load: ctx0/ctx1 claim 分支（清 pending + set claimed）
CPU complete
写回 ID → 结束 in-service
plic_store: ctx0/ctx1 complete 分支（清 claimed）
重新评估是否还有中断
可能继续拉起外部中断
上述每次写/claim/complete 后都调用 plic_update_mip()