# Buddy × LicheePi 4A（LPi4A / LPI4A）工作笔记

> 目标：把 **buddy-compiler** 的 examples 部署在 **LicheePi 4A** 上；在此基础上再 **RVV** 加速。采用 **Ubuntu 交叉编译 → 拷到板子运行**，避免在板子上编译 LLVM/MLIR 这种重工程。

---

## 1. 板子（LPi4A）

### 1.1 网络与传输

* **Ubuntu VM 与板子在同一 Wi-Fi 下已 ping 通**。
* 已建立稳定文件传输链路：**scp / rsync 可用**。
* 已把工作目录/产物从 Ubuntu 侧拷到板子。

### 1.2 资源与系统准备

* **swapfile 8G** 已创建，并写入 `/etc/fstab`（缓解板子内存紧张）。

### 1.3 基线运行验证

* 在板子上完成 **“hello + 动态库依赖检查”基线**：

  * `ld.so` 可用
  * `glibc` 可用
  * `libstdc++` 可用

## 2. Ubuntu（交叉编译）

### 2.1 本地工作目录结构

Ubuntu VM 上已整理出交叉编译与部署所需目录：

```bash
yd@yd-virtual-machine:~/riscv/lp4a$ ls
bins   lp4a-sysroot-min.tgz               sysroot
build  Miniconda3-latest-Linux-x86_64.sh  toolchain
logs   src
```

* `toolchain/`：RISC-V 工具链
* `sysroot/`：目标 sysroot
* `lp4a-sysroot-min.tgz`：最小 sysroot 压缩包（用于分发/复现）
* `build/`：构建输出目录（LLVM/MLIR / buddy-compiler 等）
* `bins/`：可执行产物/脚本集合
* `src/`：源码
* `logs/`：编译与运行日志

---

## 3. buddy-compiler 侧

### 3.1 参考路径（阶段性结论）

* 采用 buddy 官方示例（你提到的 `Buddy Compiler DeepSeekR1 Example`）作为流程模板：

  * Host 侧构建 LLVM/MLIR / buddy-compiler

---

## 4. 下一阶段计划（更新后的 TODO）


### Host/VM 端构建

* [ ] 在 Ubuntu VM（x86_64）构建 LLVM/MLIR（一次性）
* [ ] 用现有 `toolchain/` + `sysroot/` 固化交叉编译参数（CMake toolchain 文件/环境变量）
* [ ] 输出一个 **“可拷贝到板子直接跑”的产物目录**（bin + lib + 运行脚本），并在板子验证

### Phase C：buddy-compiler examples 跑通

* 选一个最小依赖 example
* 板子执行验证：

### RVV

* [ ] 切换到 `-march=rv64gcv` + 对应 pass / dialect lowering
